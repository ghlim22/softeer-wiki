## 오늘 할 일

- WAS mission 3 기능 요구사항 구현
	- `GET`메서드로 회원가입

## 오늘 배운 것

### WAS Mission 3

### 유틸함수 클래스 분리

파일 경로 파싱, 쿼리 스트링 파싱과 같은 여러 클래스가 공용으로 사용할 수 있는 기능들을 유틸 클래스로 분리하기로 하였다.

##### `/`에 대한 요청에 `/index.html` 응답

`/index.html`에서 `회원가입`을 클릭하면 `/registration`으로 이동한다. 우선, 클라이언트에게 회원가입 화면을 보여주는 것이 필요하다고 생각했다. 그래서 일반적인 웹서버처럼 `/`에서 기본적으로 `index.html`을 보여주는 설정을 추가하기로 하였다.

##### HTML 파일 수정

`/registration.html`의 회원가입 버튼이 서버에 요청을 보내지 않는 것 같았다.

`<form class="form" action="user/create" method="get">`

form에 액션과 메서드를 추가하고, 각 필드에 name속성을 추가해 쿼리스트링 생성 시에 속성을 구분하도록 하였다. 

버튼의 타입을  `button`에서 form안에 있는 버튼의 기본값인 `submit`으로 바꿨다. HTML을 몰라서 기본 속성값을 사용하기로 했다.

#### 회원가입 GET 요청 처리하기

`http://localhost:12345/user/create?userId=sadfdsaf&name=asdfasdf&password=asdfasdfsdaf`

회원가입 폼의 버튼을 클릭하면 위와 같은 `GET` 메서드 요청이 보내진다.

우선 `/user/create`에 대응하는 함수가 필요하다. 그리고 ?에 따라오는 쿼리값으로 `user` 개체를 만드는 기능이 필요하다.

### 스쿼드 세션

- 함수가 가지는 기능과 책임별로 묶어서 클래스 구조를 만들어야 한다.
- Tomcat과 NGINX의 구조를 참고하는 것도 좋을 것 같다.
- 단일 책임을 가지는 클래스 설계
- 의존성 주입
- 스레드 풀을 사용하는 이유
- Hikari CP

성훈님, 수환님과 스쿼드 세션을 진행하였다.

스레드풀을 사용했을 때의 장점에 대해 배울 수 있었다. 기존 WAS 코드는 매 연결 시에 새로운 스레드를 생성하는 방식이었다. 스레드풀은 스레드 자원을 미리 확보한 뒤, 스레드 생성이 필요할 때 이 풀의 자원을 사용한다. 그래서 기존 방법에 존재하던 스레드 생성/소멸 비용을 줄일 수 있다.

스레드풀의 크기를 정할 때는 경험칙을 사용할 수도 있고 가용 코어의 수, 스레드가 수행하는 작업이 IO bound 인지, CPU bound인지를 고려할 수 있다.

클래스를 설계할 때는 단일 책임을 가지도록 하는 것이 중요하다는 것을 알게 되었다. 아직 객체지향적으로 설계하는 것이 어떤 것인지는 모르겠지만, 두 분의 코드를 보면서 단일 책임, 의존성 줄이기 등의 원칙을 지키는 것이 향후 유지보수와 협업에 중요함을 알 수 있었다.

### 공통 피드백

- 커밋 단위는 작게 하자.
- 커밋 메시지 자세히 적자.
- json 등 로그 통일/delimeter 형식 정하고 쓰기
- optional-whitespace, 공백이 여러 개인 경우 - RFC를 보면서 스펙에 맞게 작성.
- `enum` 활용하기
- effectively final
- String의 특수성
	- Constant pool
	- 왜 굳이 string을 final로 선언해서 참조를 못 하게 만드는 것인가
- final에 대해 더 공부해보기.
	- 보통 final을 메서드 안에서는 잘 안 씀.
- 스레드풀 사이즈
	- 경험칙: CPU 연산의 비중이 아주 높으면 core + 1
	- IO bound인 경우와 CPU 바운드인 경우를 고려한다. -> 스레드가 수행하는 연산의 특성을 고려한다.
	- 경험칙을 적용할 수 있다.

### 참고 자료

https://en.wikipedia.org/wiki/Query_string

https://codingeverybody.kr/html-button-type_submit/